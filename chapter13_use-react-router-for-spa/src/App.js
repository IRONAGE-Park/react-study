import React from 'react';
import { Route, Link, Switch } from 'react-router-dom';
import Home from './Home';
import About from './About';
import Profiles from './Profiles';
import HistorySample from './HistorySample';

/*
==========Chapter 13==========
  리액트 라우터로 SPA 개발하기

==========Chapter 13.1==========
  SPA란?

  SPA는 "Single Page Application(싱글 페이지 애플리케이션)"의 약어로,
  한 개의 페이지로 이루어진 애플리케이션이라는 의미.

  전통적인 웹 페이지는 여러 페이지로 구성되어 있으며, 사용자가 다른 페이지로 이동할 때마다
  새로운 html을 받아오고, 페이지를 로딩할 때마다 서버에서 리소스를 전달받아 해석한 뒤 화면에 보여줌.
  이렇게 사용자에게 보이는 화면은 서버 측에서 준비.
    ex) 사전에 html 파일을 만들어 제공, 데이터에 따라 유동적인 html을 생성해주는 템플릿 엔진.

  요즘은 웹에서 제공되는 정보가 너무 많기 때문에 새로운 화면을 보여 주어야 할 때마다
  서버 측에서 모든 뷰를 준비하면 성능 상의 문제가 발생할 수 있음.
    ex) 트래픽 초과, 사용자가 몰려 서버에 높은 부하.
  속도와 트래픽 측면에서는 캐싱과 압축을 해서 서비스를 제공하면 어느 정도 최적화될 수 있겠지만,
  사용자와의 인터랙션이 자주 발생하는 모던 웹 애플리케이션에는 적당하지 않을 수도 있음.
  애플리케이션 내에서 화면 전환이 일어날 때마다 html을 계속 서버에 새로 요청하면,
  사용자와의 인터페이스에서 사용하고 있던 상태를 유지하는 것도 번거롭고,
  바뀌지 않는 부분까지 새로 불러와서 보여주어야 하기 때문에 불필요한 로딩이 있어서 비효율적.

  그래서 리액트 같은 라이브러리 혹은 프레임워크를 사용하여 뷰 렌더링을 사용자의 브라우저가 담당하도록 하고,
  우선 애플리케이션을 브라우저에 불러와서 실행시킨 후에 사용자와의 인터랙션이 발생하면 필요한 부분만 업데이트.
  만약 새로운 데이터가 필요하다면 서버 API를 호출하여 필요한 데이터만 새로 불러와 애플리케이션에서 사용.


  싱글 페이지는 서버에서 사용자에게 제공하는 페이지는 한 종류이지만, 해당 페이지에서 로딩된 자바스크립트와
  현재 사용자 브라우저의 주소 상태에 따라 다양한 화면을 보여줄 수 있음.(블로그의 홈, 포스트 목록, 글쓰기, 포스트 등)
  다른 주소에 다른 화면을 보여 주는 것을 "라우팅"이라고 함.
  이는 리액트 라이브러리 자체에 내장된 기능은 아니지만, 브라우저의 API를 직접 사용하여 관리하거나 라이브러리를 통해 구현 가능.

  리액트 라우팅 라이브러리는 '리액트 라우터(react-router)', '리치 라우터(reach-router)', 'Next.js' 등이 있음.
  이 중 리액트 라우터는 클라이언트 사이드에서 이루어지는 라우팅을 아주 간단하게 구현할 수 있도록 해주며,
  더 나아가서 "서버 사이드 렌더링"을 할 때도 라우팅을 도와주는 컴포넌트들을 제공.

==========Chapter 13.1.1==========
  SPA의 단점

  SPA는 앱의 규모가 커지면 페이지 로딩 시 사용자가 실제로 방문하지 않을 수도 있는
  페이지의 스크립트도 불러오기 때문에 자바스크립트 파일이 너무 커진다는 단점이 있음.
  하지만 이는 "코드 스플리팅(code splitting)"을 사용하면 라우트 별로 파일을 나누어서 트래픽과 로딩 속도를 개선할 수 있음.

  리액트 라우터처럼 브라우저에서 자바스크립트를 사용하여 라우팅을 관리하는 것은
  자바스크립트를 실행하지 않는 일반 크롤러에서는 페이지의 정보를 제대로 수집해 가지 못한다는 잠재적인 단점 존재.
  => 때문에 구글, 네이버, 다음 같은 검색 엔진의 검색 결과에 페이지가 잘 나타나지 않을 수도 있음.

  또한, 자바스크립트가 실행될 때까지 페이지가 비어 있기 때문에 자바스크립트 파일이 로딩되어 실행되는
  짧은 시간 동안 흰 페이지가 나타날 수도 있다는 단점도 존재함.

  이러한 문제점들은 "서버 사이드 렌더링(server-side rendering)"을 통해 모두 해결할 수 있음.
*/



/*
==========Chapter 13.2.4==========
  Route 컴포넌트로 특정 주소에 컴포넌트 연결

  Route 컴포넌트를 사용하면 어떤 규칙을 가진 경로에 어떤 컴포넌트를 보여 줄지 정의할 수 있음.
  
  Example) <Route path="주소 규칙" component={보여 줄 컴포넌트} />

  여기서 /about 경로로 들어가면 Home 컴포넌트와 About 컴포넌트 모두 나오는데,
  /about 경로가 / 규칙에도 일치하기 때문에 발생한 현상.

  이를 수정하려면 Home을 위한 Route 컴포넌트를 사용할 때 exact라는 props를 true로 설정하면 됨.

==========Chapter 13.2.5==========
  Link 컴포넌트를 사용하여 다른 주소로 이동하기

  Link 컴포넌트는 클릭하면 다른 주소로 이동시켜 주는 컴포넌트.
  일반 웹 애플리케이션에서는 a 태그를 사용하여 페이지를 전환하는데, 리액트 라우터를 사용할 때는 이 태그를 직접 사용하면 안 됨.
  a 태그는 페이지를 전환하는 과정에서 페이지를 새로 불러오기 때문에 애플리케이션이 들고 있던 상태들을 모두 날려 버리게 됨.
  => 렌더링된 컴포넌트들도 모두 사라지고 다시 처음부터 렌더링.

  Link 컴포넌트를 사용하여 페이지를 전환하면, 페이지를 새로 불러오지 않고 애플리케이션은 그대로 유지한 상태에서
  HTML5 History API를 사용하여 페이지의 주소만 변경해 줌.
  Link 컴포넌트 자체는 a 태그로 이루어져 있지만, 페이지 전환을 방지하는 기장이 내장되어 있음.

  Example) <Link to="주소">내용</Link>
*/

const App = () => {
  /*
  ==========Chapter 13.3==========
    Route 하나에 여러 개의 path 설정하기

    Route 하나에 여러 개의 path를 지정하는 것은 최신 버전의 리액트 라우터 v5부터 적용된 기능.
    이전 버전에서는 여러 개의 path에 같은 컴포넌트를 보여주고 싶다면 Route 컴포넌트를 여러 개 생성해야 했지만,
    현재는 path props를 배열로 설정해 주면 여러 경로에서 같은 컴포넌트를 보여줄 수 있음.
  */

  /*
  ==========Chapter 13.6.3==========
    Switch

    Switch 컴포넌트는 여러 Route를 감싸서 그중 일치하는 단 하나의 라우트만을 렌더링시켜 줌.
    Switch를 사용하면 모든 규칙과 일치하지 않을 때 보여 줄 Not Found 페이지도 구현할 수 있음.
  */
  return (
    <div className="App">
      <ul>
        <li>
          <Link to="/">홈</Link>
        </li>
        <li>
          <Link to="/about">소개</Link>
        </li>
        <li>
          <Link to="/profiles">프로필</Link>
        </li>
        <li>
          <Link to="/history">History 예제</Link>
        </li>
      </ul>
      <Switch>
        <Route path="/" component={Home} exact={true} />
        {/* 
          <Route path="/about" component={About} />
          <Route path="info" component={About} />
        */}

        {/* 
          path 규칙에는 /profile/:username 이라고 설정.
          이렇게 설정하면 match.params.username 값을 통해 현재 username 값을 조회할 수 있음.
        */}
        <Route path={['/about', '/info']} component={About} />
        <Route path="/profiles" component={Profiles} />
        <Route path="/history" component={HistorySample} />
        <Route
          // path를 따로 정의하지 않으면 모든 상황에 렌더링됨
          // Switch 구문 덕에 위 페이지들은 존재하는 페이지로 간주하여 이 경우를 렌더하지 않고,
          // 위 규칙에 어긋나는 URL은 감지하여 존재하지 않는 페이지를 렌더.
          render={({ location }) => (
            <div>
              <h2>이 페이지는 존재하지 않습니다:</h2>
              <p>{location.pathname}</p>
            </div>
          )}
        />
      </Switch>
    </div>
  );
}

export default App;

/*
==========Chapter 13.7==========
  정리

  큰 규모의 프로젝트를 진행하다 보면 한 가지 문제가 발생함.
  바로 웹 브라우저에서 사용할 컴포넌트, 상태 관리를 하는 로직,
  그 외 여러 기능을 구현하는 함수들이 점점 쌓이면서 최종 결과물인
  자바스크립트 파일의 크기가 매우 커진다는 점.

  예를 들어 방금 만든 프로젝트는 사용자가 /about 페이지에 들어왔을 때
  지금 당장 필요하지 않은 Profile 컴포넌트까지 불러옴.

  라우트에 따라 필요한 컴포넌트만 불러오고, 다른 컴포넌트는 다른 페이지를 방문하는 등의
  필요한 시점에 불러오면 매우 효율적임. => 이를 해결해 주는 기술이 "코드 스플리팅".
*/